{
    "scopeName": "source.cadence",
    "patterns": [
      { "include": "#comments" },
      { "include": "#expressions" },
      { "include": "#declarations" },
      { "include": "#keywords" },
      { "include": "#code-block" },
      { "include": "#composite" },
      { "include": "#event" },
      { "include": "#entitlement" }
    ],
    "repository": {
      "comments": {
        "patterns": [
          {
            "name": "comment.line.number-sign.cadence",
            "match": "\\A^(#!).*$\\n?",
            "captures": {
              "1": {
                "name": "punctuation.definition.comment.cadence"
              }
            }
          },
          {
            "name": "comment.block.documentation.cadence",
            "begin": "/\\*\\*(?!/)",
            "end": "\\*/",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.begin.cadence"
              }
            },
            "endCaptures": {
              "0": {
                "name": "punctuation.definition.comment.end.cadence"
              }
            },
            "patterns": [
              {
                "include": "#comments-nested"
              }
            ]
          },
          {
            "name": "comment.block.documentation.playground.cadence",
            "begin": "/\\*:",
            "end": "\\*/",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.begin.cadence"
              }
            },
            "endCaptures": {
              "0": {
                "name": "punctuation.definition.comment.end.cadence"
              }
            },
            "patterns": [
              {
                "include": "#comments-nested"
              }
            ]
          },
          {
            "name": "comment.block.cadence",
            "begin": "/\\*",
            "end": "\\*/",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.begin.cadence"
              }
            },
            "endCaptures": {
              "0": {
                "name": "punctuation.definition.comment.end.cadence"
              }
            },
            "patterns": [
              {
                "include": "#comments-nested"
              }
            ]
          },
          {
            "name": "invalid.illegal.unexpected-end-of-block-comment.cadence",
            "match": "\\*/"
          },
          {
            "begin": "(^[ \\t]+)?(?=//)",
            "end": "(?!\\G)",
            "beginCaptures": {
              "1": {
                "name": "punctuation.whitespace.comment.leading.cadence"
              }
            },
            "patterns": [
              {
                "name": "comment.line.triple-slash.documentation.cadence",
                "begin": "///",
                "end": "$",
                "beginCaptures": {
                  "0": {
                    "name": "punctuation.definition.comment.cadence"
                  }
                }
              },
              {
                "name": "comment.line.double-slash.documentation.cadence",
                "begin": "//:",
                "end": "$",
                "beginCaptures": {
                  "0": {
                    "name": "punctuation.definition.comment.cadence"
                  }
                }
              },
              {
                "name": "comment.line.double-slash.cadence",
                "begin": "//",
                "end": "$",
                "beginCaptures": {
                  "0": {
                    "name": "punctuation.definition.comment.cadence"
                  }
                }
              }
            ]
          }
        ]
      },
      "comments-nested": {
        "begin": "/\\*",
        "end": "\\*/",
        "patterns": [
          {
            "include": "#comments-nested"
          }
        ]
      },
      "literals": {
        "patterns": [
          {
            "include": "#boolean"
          },
          {
            "include": "#numeric"
          },
          {
            "include": "#string"
          },
          {
            "include": "#path"
          },
          {
            "match": "\\bnil\\b",
            "name": "constant.language.nil.cadence"
          }
        ],
        "repository": {
          "boolean": {
            "match": "\\b(true|false)\\b",
            "name": "constant.language.boolean.cadence"
          },
          "numeric": {
            "patterns": [
              {
                "include": "#binary"
              },
              {
                "include": "#octal"
              },
              {
                "include": "#fixed-point"
              },
              {
                "include": "#decimal"
              },
              {
                "include": "#hexadecimal"
              }
            ],
            "repository": {
              "fixed-point": {
                "comment": "Matches fixed-point numbers like 1.0, -123.456, 1.0, 1_000.0",
                "match": "(\\B\\-|\\b)[0-9]([_0-9]*[0-9])?\\.[0-9]([_0-9]*[0-9])?\\b",
                "name": "constant.numeric.fixed-point.cadence"
              },
              "binary":  {
                "comment": "",
                "match": "(\\B\\-|\\b)0b[01]([_01]*[01])?\\b",
                "name": "constant.numeric.integer.binary.cadence"
              },
              "octal":  {
                "comment": "",
                "match": "(\\B\\-|\\b)0o[0-7]([_0-7]*[0-7])?\\b",
                "name": "constant.numeric.integer.octal.cadence"
              },
              "decimal":  {
                "comment": "",
                "match": "(\\B\\-|\\b)[0-9]([_0-9]*[0-9])?\\b",
                "name": "constant.numeric.integer.decimal.cadence"
              },
              "hexadecimal":  {
                "comment": "",
                "match": "(\\B\\-|\\b)0x[0-9A-Fa-f]([_0-9A-Fa-f]*[0-9A-Fa-f])?\\b",
                "name": "constant.numeric.integer.hexadecimal.cadence"
              }
            }
          },
          "string": {
            "patterns": [
              {
                "begin": "\"",
                "beginCaptures": {
                  "0": {
                    "name": "punctuation.definition.string.begin.cadence"
                  }
                },
                "end": "\"",
                "endCaptures": {
                  "0": {
                    "name": "punctuation.definition.string.end.cadence"
                  }
                },
                "name": "string.quoted.double.single-line.cadence",
                "patterns": [
                  {
                    "match": "\\r|\\n",
                    "name": "invalid.illegal.returns-not-allowed.cadence"
                  },
                  {
                    "include": "#string-guts"
                  }
                ]
              }
            ],
            "repository": {
              "string-guts": {
                "patterns": [
                  {
                    "match": "\\\\[0\\\\tnr\"']",
                    "name": "constant.character.escape.cadence"
                  },
                  {
                    "match": "\\\\u\\{[0-9a-fA-F]{1,8}\\}",
                    "name": "constant.character.escape.unicode.cadence"
                  }
                ]
              }
            }
          },
          "path": {
            "match": "/(storage|private|public)/[\\p{L}_][\\p{L}_\\p{N}\\p{M}]*\\b",
            "name": "constant.language.path.cadence"
          }
        }
      },
      "operators": {
        "patterns": [
          {
            "comment": "Type casting",
            "name": "keyword.other.operator.cadence",
            "match": "\\bas([!?]\\B|\\b)"
          },
          {
            "name": "keyword.other.operator.cadence",
            "match": "(?<!\\.)\\b(?:create|destroy|emit)\\b"
          },
          {
            "comment": "This rule helps us speed up the matching.",
            "begin": "(?x)\n(?=\n  (?<oph>                # operator-head\n    [/=\\-+!*%<>&|^~?]\n    | [\\x{00A1}-\\x{00A7}]\n    | [\\x{00A9}\\x{00AB}]\n    | [\\x{00AC}\\x{00AE}]\n    | [\\x{00B0}-\\x{00B1}\\x{00B6}\\x{00BB}\\x{00BF}\\x{00D7}\\x{00F7}]\n    | [\\x{2016}-\\x{2017}\\x{2020}-\\x{2027}]\n    | [\\x{2030}-\\x{203E}]\n    | [\\x{2041}-\\x{2053}]\n    | [\\x{2055}-\\x{205E}]\n    | [\\x{2190}-\\x{23FF}]\n    | [\\x{2500}-\\x{2775}]\n    | [\\x{2794}-\\x{2BFF}]\n    | [\\x{2E00}-\\x{2E7F}]\n    | [\\x{3001}-\\x{3003}]\n    | [\\x{3008}-\\x{3030}]\n  )\n  | \\.\n  (\n    \\g<oph>              # operator-head\n    | \\.\n    | [\\x{0300}-\\x{036F}]        # operator-character\n    | [\\x{1DC0}-\\x{1DFF}]\n    | [\\x{20D0}-\\x{20FF}]\n    | [\\x{FE00}-\\x{FE0F}]\n    | [\\x{FE20}-\\x{FE2F}]\n    | [\\x{E0100}-\\x{E01EF}]\n  )\n)",
            "end": "(?!\\G)",
            "patterns": [
              {
                "comment": "Prefix unary operator",
                "match": "(?x)\n\\G                    # Matching from the beginning ensures\n                    # that we start with operator-head\n(?<=^|[\\s(\\[{,;:])\n(\n  (?!(//|/\\*|\\*/))\n  (\n    [/=\\-+!*%<>&|^~?]        # operator-head\n    | [\\x{00A1}-\\x{00A7}]\n    | [\\x{00A9}\\x{00AB}]\n    | [\\x{00AC}\\x{00AE}]\n    | [\\x{00B0}-\\x{00B1}\\x{00B6}\\x{00BB}\\x{00BF}\\x{00D7}\\x{00F7}]\n    | [\\x{2016}-\\x{2017}\\x{2020}-\\x{2027}]\n    | [\\x{2030}-\\x{203E}]\n    | [\\x{2041}-\\x{2053}]\n    | [\\x{2055}-\\x{205E}]\n    | [\\x{2190}-\\x{23FF}]\n    | [\\x{2500}-\\x{2775}]\n    | [\\x{2794}-\\x{2BFF}]\n    | [\\x{2E00}-\\x{2E7F}]\n    | [\\x{3001}-\\x{3003}]\n    | [\\x{3008}-\\x{3030}]\n  \n    | [\\x{0300}-\\x{036F}]        # operator-character\n    | [\\x{1DC0}-\\x{1DFF}]\n    | [\\x{20D0}-\\x{20FF}]\n    | [\\x{FE00}-\\x{FE0F}]\n    | [\\x{FE20}-\\x{FE2F}]\n    | [\\x{E0100}-\\x{E01EF}]\n  )\n)++\n(?![\\s)\\]},;:]|\\z)",
                "captures": {
                  "0": {
                    "patterns": [
                      {
                        "name": "keyword.operator.arithmetic.unary.cadence",
                        "match": "\\G(\\+|\\-)$"
                      },
                      {
                        "name": "keyword.operator.logical.not.cadence",
                        "match": "\\G!$"
                      },
                      {
                        "name": "keyword.operator.move.cadence",
                        "match": "\\G<-!?$"
                      }
                    ]
                  }
                }
              },
              {
                "comment": "Postfix unary operator",
                "match": "(?x)\n\\G                    # Matching from the beginning ensures\n                    # that we start with operator-head\n(?<!^|[\\s(\\[{,;:])\n(\n  (?!(//|/\\*|\\*/))\n  (\n    [/=\\-+!*%<>&|^~?]        # operator-head\n    | [\\x{00A1}-\\x{00A7}]\n    | [\\x{00A9}\\x{00AB}]\n    | [\\x{00AC}\\x{00AE}]\n    | [\\x{00B0}-\\x{00B1}\\x{00B6}\\x{00BB}\\x{00BF}\\x{00D7}\\x{00F7}]\n    | [\\x{2016}-\\x{2017}\\x{2020}-\\x{2027}]\n    | [\\x{2030}-\\x{203E}]\n    | [\\x{2041}-\\x{2053}]\n    | [\\x{2055}-\\x{205E}]\n    | [\\x{2190}-\\x{23FF}]\n    | [\\x{2500}-\\x{2775}]\n    | [\\x{2794}-\\x{2BFF}]\n    | [\\x{2E00}-\\x{2E7F}]\n    | [\\x{3001}-\\x{3003}]\n    | [\\x{3008}-\\x{3030}]\n  \n    | [\\x{0300}-\\x{036F}]        # operator-character\n    | [\\x{1DC0}-\\x{1DFF}]\n    | [\\x{20D0}-\\x{20FF}]\n    | [\\x{FE00}-\\x{FE0F}]\n    | [\\x{FE20}-\\x{FE2F}]\n    | [\\x{E0100}-\\x{E01EF}]\n  )\n)++\n(?=[\\s)\\]},;:]|\\z)",
                "captures": {
                  "0": {
                    "patterns": [
                      {
                        "name": "keyword.operator.force-unwrap.cadence",
                        "match": "\\G!$"
                      }
                    ]
                  }
                }
              },
              {
                "comment": "Infix operator",
                "match": "(?x)\n\\G                    # Matching from the beginning ensures\n                    # that we start with operator-head\n(\n  (?!(//|/\\*|\\*/))\n  (\n    [/=\\-+!*%<>&|^~?]        # operator-head\n    | [\\x{00A1}-\\x{00A7}]\n    | [\\x{00A9}\\x{00AB}]\n    | [\\x{00AC}\\x{00AE}]\n    | [\\x{00B0}-\\x{00B1}\\x{00B6}\\x{00BB}\\x{00BF}\\x{00D7}\\x{00F7}]\n    | [\\x{2016}-\\x{2017}\\x{2020}-\\x{2027}]\n    | [\\x{2030}-\\x{203E}]\n    | [\\x{2041}-\\x{2053}]\n    | [\\x{2055}-\\x{205E}]\n    | [\\x{2190}-\\x{23FF}]\n    | [\\x{2500}-\\x{2775}]\n    | [\\x{2794}-\\x{2BFF}]\n    | [\\x{2E00}-\\x{2E7F}]\n    | [\\x{3001}-\\x{3003}]\n    | [\\x{3008}-\\x{3030}]\n  \n    | [\\x{0300}-\\x{036F}]        # operator-character\n    | [\\x{1DC0}-\\x{1DFF}]\n    | [\\x{20D0}-\\x{20FF}]\n    | [\\x{FE00}-\\x{FE0F}]\n    | [\\x{FE20}-\\x{FE2F}]\n    | [\\x{E0100}-\\x{E01EF}]\n  )\n)++",
                "captures": {
                  "0": {
                    "patterns": [
                      {
                        "name": "keyword.operator.assignment.cadence",
                        "match": "\\G=$"
                      },
                      {
                        "name": "keyword.operator.arithmetic.cadence",
                        "match": "\\G(\\+|\\-|\\*|/)$"
                      },
                      {
                        "name": "keyword.operator.arithmetic.remainder.cadence",
                        "match": "\\G%$"
                      },
                      {
                        "name": "keyword.operator.comparison.cadence",
                        "match": "\\G(==|!=|>|<|>=|<=)$"
                      },
                      {
                        "name": "keyword.operator.swap.cadence",
                        "match": "\\G<->$"
                      },
                      {
                        "name": "keyword.operator.coalescing.cadence",
                        "match": "\\G\\?\\?$"
                      },
                      {
                        "name": "keyword.operator.logical.cadence",
                        "match": "\\G(&&|\\|\\|)$"
                      },
                      {
                        "name": "keyword.operator.bitwise.cadence",
                        "match": "\\G(&|\\||\\^|<<|>>)$"
                      },
                      {
                        "name": "keyword.operator.ternary.cadence",
                        "match": "\\G\\?$"
                      }
                    ]
                  }
                }
              }
            ]
          },
          {
            "name": "keyword.operator.ternary.cadence",
            "match": ":"
          }
        ]
      },
      "keywords": {
        "patterns": [
          {
            "name": "keyword.control.branch.cadence",
            "match": "(?<!\\.)\\b(?:if|else|switch|case|default)\\b"
          },
          {
            "name": "keyword.control.transfer.cadence",
            "match": "(?<!\\.)\\b(?:continue|break|return)\\b"
          },
          {
            "name": "keyword.control.loop.cadence",
            "match": "(?<!\\.)\\b(?:while|for|in)\\b"
          },
          {
            "name": "keyword.other.entitlement.cadence",
            "match": "(?<!\\.)\\b(?:entitlement)\\b"
          },
          {
            "name": "storage.type.$1.cadence",
            "match": "(?<!\\.)\\b(struct|resource|enum|event)\\b"
          },
          {
            "name": "storage.modifier.cadence",
            "match": "(?<!\\.)\\b(?:view|static|native)\\b"
          },
          {
            "name": "keyword.other.declaration-specifier.accessibility.cadence",
            "match": "(?<!\\.)\\b(?:access\\((?:self|contract|account|all)\\))\\b"
          },
          {
            "name": "storage.type.function.cadence",
            "match": "\\binit\\b|(?<!\\.)\\b(?:fun)\\b"
          },
          {
            "name": "variable.language.cadence",
            "match": "(?<!\\.)\\bself\\b"
          },
          {
            "name": "keyword.control.import.cadence",
            "match": "(?<!\\.)\\b(?:import|from)\\b"
          },
          {
            "name": "keyword.other.cadence",
            "match": "(?<!\\.)\\b(?:pre|post|prepare|execute)\\b"
          }
        ]
      },
      "code-block": {
        "begin": "\\{",
        "end": "\\}",
        "beginCaptures": {
          "0": {
            "name": "punctuation.section.scope.begin.cadence"
          }
        },
        "endCaptures": {
          "0": {
            "name": "punctuation.section.scope.end.cadence"
          }
        },
        "patterns": [
          {
            "include": "$self"
          }
        ]
      },
      "function": {
        "begin": "\\b(fun)\\b\\s+([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)\\s*",
        "beginCaptures": {
          "1": {
            "name": "storage.type.function.cadence"
          },
          "2": {
            "name": "entity.name.function.cadence"
          }
        },
        "end": "(?<=\\})|$",
        "name": "meta.definition.function.cadence",
        "patterns": [
          {
            "include": "#comments"
          },
          {
            "include": "#parameter-clause"
          },
          {
            "include": "#function-result"
          },
          {
            "begin": "(\\{)",
            "beginCaptures": {
              "1": {
                "name": "punctuation.section.function.begin.cadence"
              }
            },
            "end": "(\\})",
            "endCaptures": {
              "1": {
                "name": "punctuation.section.function.end.cadence"
              }
            },
            "name": "meta.definition.function.body.cadence",
            "patterns": [
              {
                "include": "$self"
              }
            ]
          }
        ]
      },
      "initializer": {
        "begin": "(?<!\\.)\\b(init)\\s*(?=\\(|<)",
        "beginCaptures": {
          "1": {
            "name": "storage.type.function.cadence"
          }
        },
        "end": "(?<=\\})|$",
        "name": "meta.definition.function.initializer.cadence",
        "patterns": [
          {
            "include": "#comments"
          },
          {
            "include": "#parameter-clause"
          },
          {
            "begin": "(\\{)",
            "beginCaptures": {
              "1": {
                "name": "punctuation.section.function.begin.cadence"
              }
            },
            "end": "(\\})",
            "endCaptures": {
              "1": {
                "name": "punctuation.section.function.end.cadence"
              }
            },
            "name": "meta.definition.function.body.cadence",
            "patterns": [
              {
                "include": "$self"
              }
            ]
          }
        ]
      },
      "function-result": {
        "begin": "(?<![/=\\-+!*%<>&|\\^~.])(:)(?![/=\\-+!*%<>&|\\^~.])\\s*",
        "beginCaptures": {
          "1": {
            "name": "keyword.operator.function-result.cadence"
          }
        },
        "end": "(?!\\G)(?=\\{|;)|$",
        "name": "meta.function-result.cadence",
        "patterns": [
          {
            "include": "#type"
          }
        ]
      },
      "expressions": {
        "patterns": [
          { "include": "#comments" },
          { "include": "#function-call-expression" },
          { "include": "#literals" },
          { "include": "#operators" },
          { "include": "#keywords" }
        ]
      },
      "function-call-expression": {
        "patterns": [
          {
            "begin": "(?!init)([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)\\s*(\\()",
            "beginCaptures": {
              "1": {
                "name": "support.function.any-method.cadence"
              },
              "4": {
                "name": "punctuation.definition.arguments.begin.cadence"
              }
            },
            "comment": "foo(args) -- a call whose callee is a highlightable name",
            "end": "\\)",
            "endCaptures": {
              "0": {
                "name": "punctuation.definition.arguments.end.cadence"
              }
            },
            "name": "meta.function-call.cadence",
            "patterns": [
              {
                "include": "#expression-element-list"
              }
            ]
          }
        ]
      },
      "expression-element-list": {
        "patterns": [
          {
            "include": "#comments"
          },
          {
            "begin": "([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)\\s*(:)",
            "beginCaptures": {
              "1": {
                "name": "support.function.any-method.cadence"
              },
              "2": {
                "name": "punctuation.separator.argument-label.cadence"
              }
            },
            "comment": "an element with a label",
            "end": "(?=[,)\\]])",
            "patterns": [
              {
                "include": "#expressions"
              }
            ]
          },
          {
            "begin": "(?![,)\\]])(?=\\S)",
            "comment": "an element without a label (i.e. anything else)",
            "end": "(?=[,)\\]])",
            "patterns": [
              {
                "include": "#expressions"
              }
            ]
          }
        ]
      },
      "declarations": {
        "patterns": [
          { "include": "#var-let-declaration" },
          { "include": "#function" },
          { "include": "#initializer" }
        ]
      },
      "var-let-declaration": {
        "begin": "\\b(var|let)\\b\\s+([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)",
        "beginCaptures": {
          "1": {
            "name": "storage.type.$1.cadence"
          },
          "2": {
            "name": "entity.name.type.$1.cadence"
          }
        },
        "end": "=|<-|<-!|$",
        "patterns": [
          { "include": "#type" }
        ]
      },
      "type": {
        "patterns": [
          {
            "include": "#comments"
          },
          {
            "match": "([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)",
            "name": "storage.type.cadence"
          }
        ]
      },
      "parameter-clause": {
        "begin": "(\\()",
        "beginCaptures": {
          "1": {
            "name": "punctuation.definition.parameters.begin.cadence"
          }
        },
        "end": "(\\))",
        "endCaptures": {
          "1": {
            "name": "punctuation.definition.parameters.end.cadence"
          }
        },
        "name": "meta.parameter-clause.cadence",
        "patterns": [
          {
            "include": "#parameter-list"
          }
        ]
      },
      "parameter-list": {
        "patterns": [
          {
            "match": "([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)\\s+([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)(?=\\s*:)",
            "captures": {
              "1": {
                "name": "entity.name.function.cadence"
              },
              "2": {
                "name": "variable.parameter.function.cadence"
              }
            },
            "comment": "External parameter labels are considered part of the function name"
          },
          {
            "match": "(([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*))(?=\\s*:)",
            "captures": {
              "1": {
                "name": "variable.parameter.function.cadence"
              },
              "2": {
                "name": "entity.name.function.cadence"
              }
            },
            "comment": "If no external label is given, the name is both the external label and the internal variable name"
          },
          {
            "begin": ":\\s*(?!\\s)",
            "end": "(?=[,)])",
            "patterns": [
              {
                "include": "#type"
              },
              {
                "match": ":",
                "name": "invalid.illegal.extra-colon-in-parameter-list.cadence"
              }
            ]
          }
        ]
      },
      "event": {
        "begin": "\\b(event)\\b\\s+([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)\\s*",
        "beginCaptures": {
          "1": {
            "name": "storage.type.event.cadence"
          },
          "2": {
            "name": "entity.name.type.event.cadence"
          }
        },
        "end": "(?<=\\))|$",
        "name": "meta.definition.type.event.cadence",
        "patterns": [
          {
            "include": "#comments"
          },
          {
            "include": "#parameter-clause"
          }
        ]
      },
      "composite": {
        "begin": "\\b((?:(?:struct|resource|contract)(?:\\s+interface)?)|transaction|enum)\\s+([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)",
        "beginCaptures": {
          "1": {
            "name": "storage.type.$1.cadence"
          },
          "2": {
            "name": "entity.name.type.$1.cadence"
          }
        },
        "end": "(?<=\\})",
        "name": "meta.definition.type.composite.cadence",
        "patterns": [
          {
            "include": "#comments"
          },
          {
            "include": "#conformance-clause"
          },
          {
            "begin": "\\{",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.type.begin.cadence"
              }
            },
            "end": "\\}",
            "endCaptures": {
              "0": {
                "name": "punctuation.definition.type.end.cadence"
              }
            },
            "name": "meta.definition.type.body.cadence",
            "patterns": [
              {
                "include": "$self"
              }
            ]
          }
        ]
      },
      "conformance-clause": {
        "begin": "(:)(?=\\s*\\{)|(:)\\s*",
        "beginCaptures": {
          "1": {
            "name": "invalid.illegal.empty-conformance-clause.cadence"
          },
          "2": {
            "name": "punctuation.separator.conformance-clause.cadence"
          }
        },
        "end": "(?!\\G)$|(?=[={}])",
        "name": "meta.conformance-clause.cadence",
        "patterns": [
          {
            "begin": "\\G",
            "end": "(?!\\G)$|(?=[={}])",
            "patterns": [
              {
                "include": "#comments"
              },
              {
                "include": "#type"
              }
            ]
          }
        ]
      },
      "entitlement": {
          "match": "\\b(entitlement)\\b\\s+([\\p{L}_][\\p{L}_\\p{N}\\p{M}]*)\\s*",
          "captures": {
            "1": {
              "name": "storage.type.entitlement.cadence"
            },
            "2": {
              "name": "entity.name.type.entitlement.cadence"
            }
          },
          "name": "meta.definition.type.entitlement.cadence"
        }
      }
  }
